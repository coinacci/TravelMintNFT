{
  "language": "Solidity",
  "sources": {
    "TravelNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract TravelNFT is ERC721, ERC721URIStorage, Ownable, ReentrancyGuard {\n    uint256 private _nextTokenId;\n    \n    // USDC contract on Base\n    IERC20 public constant USDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);\n    \n    // Fixed mint price: 1 USDC (6 decimals)\n    uint256 public constant MINT_PRICE = 1000000; // 1 USDC\n    \n    // Events\n    event TravelNFTMinted(address indexed to, uint256 indexed tokenId, string location);\n    event RoyaltyPaid(uint256 indexed tokenId, address indexed recipient, uint256 amount);\n    \n    // Struct for NFT metadata\n    struct TravelMetadata {\n        string location;\n        string latitude;\n        string longitude; \n        string category;\n        uint256 mintTimestamp;\n        address originalMinter;\n    }\n    \n    mapping(uint256 => TravelMetadata) public travelMetadata;\n    \n    constructor(address initialOwner) \n        ERC721(\"TravelMint NFT\", \"TRAVEL\") \n        Ownable(initialOwner)\n    {\n        _nextTokenId = 1;\n    }\n    \n    function mintTravelNFT(\n        address to,\n        string memory location,\n        string memory latitude,\n        string memory longitude,\n        string memory category,\n        string memory tokenURI\n    ) public nonReentrant returns (uint256) {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(bytes(location).length > 0, \"Location cannot be empty\");\n        require(bytes(tokenURI).length > 0, \"Token URI cannot be empty\");\n        \n        // Transfer USDC from sender to contract owner\n        bool success = USDC.transferFrom(msg.sender, owner(), MINT_PRICE);\n        require(success, \"USDC transfer failed\");\n        \n        uint256 tokenId = _nextTokenId++;\n        \n        // Mint NFT\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n        \n        // Store travel metadata\n        travelMetadata[tokenId] = TravelMetadata({\n            location: location,\n            latitude: latitude, \n            longitude: longitude,\n            category: category,\n            mintTimestamp: block.timestamp,\n            originalMinter: msg.sender\n        });\n        \n        emit TravelNFTMinted(to, tokenId, location);\n        \n        return tokenId;\n    }\n    \n    function batchMintTravelNFT(\n        address[] memory recipients,\n        string[] memory locations,\n        string[] memory latitudes,\n        string[] memory longitudes,\n        string[] memory categories,\n        string[] memory tokenURIs\n    ) external nonReentrant returns (uint256[] memory) {\n        require(recipients.length == locations.length, \"Arrays length mismatch\");\n        require(recipients.length == latitudes.length, \"Arrays length mismatch\");\n        require(recipients.length == longitudes.length, \"Arrays length mismatch\");\n        require(recipients.length == categories.length, \"Arrays length mismatch\");\n        require(recipients.length == tokenURIs.length, \"Arrays length mismatch\");\n        \n        uint256[] memory tokenIds = new uint256[](recipients.length);\n        uint256 totalCost = MINT_PRICE * recipients.length;\n        \n        // Transfer total USDC amount\n        bool success = USDC.transferFrom(msg.sender, owner(), totalCost);\n        require(success, \"USDC transfer failed\");\n        \n        for (uint256 i = 0; i < recipients.length; i++) {\n            uint256 tokenId = _nextTokenId++;\n            \n            _safeMint(recipients[i], tokenId);\n            _setTokenURI(tokenId, tokenURIs[i]);\n            \n            travelMetadata[tokenId] = TravelMetadata({\n                location: locations[i],\n                latitude: latitudes[i],\n                longitude: longitudes[i], \n                category: categories[i],\n                mintTimestamp: block.timestamp,\n                originalMinter: msg.sender\n            });\n            \n            tokenIds[i] = tokenId;\n            emit TravelNFTMinted(recipients[i], tokenId, locations[i]);\n        }\n        \n        return tokenIds;\n    }\n    \n    function getTravelMetadata(uint256 tokenId) external view returns (TravelMetadata memory) {\n        require(_exists(tokenId), \"Token does not exist\");\n        return travelMetadata[tokenId];\n    }\n    \n    function getNextTokenId() external view returns (uint256) {\n        return _nextTokenId;\n    }\n    \n    function withdrawUSDC() external onlyOwner {\n        uint256 balance = USDC.balanceOf(address(this));\n        require(balance > 0, \"No USDC to withdraw\");\n        \n        bool success = USDC.transfer(owner(), balance);\n        require(success, \"USDC withdrawal failed\");\n    }\n    \n    function updateMintPrice(uint256 newPrice) external onlyOwner {\n        revert(\"Mint price is fixed at 1 USDC\");\n    }\n\n    // Required overrides\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false
    },
    "outputSelection": {
      "*": {
        "*": ["*"]
      }
    }
  }
}

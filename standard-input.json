{
  "language": "Solidity",
  "sources": {
    "contracts/TravelNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract TravelNFT is ERC721, ERC721URIStorage, Ownable, ReentrancyGuard {\n    uint256 private _nextTokenId;\n    \n    // USDC contract on Base\n    IERC20 public constant USDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);\n    \n    // Fixed mint price: 1 USDC (6 decimals)\n    uint256 public constant MINT_PRICE = 1000000; // 1 USDC\n    \n    // Platform commission wallet\n    address public constant PLATFORM_WALLET = 0x7CDe7822456AAC667Df0420cD048295b92704084;\n    \n    // Platform commission: 5%\n    uint256 public constant PLATFORM_FEE_PERCENT = 5;\n    \n    // Events\n    event TravelNFTMinted(address indexed to, uint256 indexed tokenId, string location);\n    event RoyaltyPaid(uint256 indexed tokenId, address indexed recipient, uint256 amount);\n    event NFTPurchased(uint256 indexed tokenId, address indexed buyer, address indexed seller, uint256 price, uint256 platformFee);\n    event NFTListed(uint256 indexed tokenId, address indexed seller, uint256 price);\n    event NFTUnlisted(uint256 indexed tokenId, address indexed seller);\n    event PriceUpdated(uint256 indexed tokenId, address indexed seller, uint256 oldPrice, uint256 newPrice);\n    \n    // Struct for NFT metadata\n    struct TravelMetadata {\n        string location;\n        string latitude;\n        string longitude; \n        string category;\n        uint256 mintTimestamp;\n        address originalMinter;\n    }\n    \n    mapping(uint256 => TravelMetadata) public travelMetadata;\n    \n    // ðŸ”’ SECURITY FIX: On-chain listing system\n    struct Listing {\n        address seller;\n        uint256 price;\n        bool active;\n    }\n    \n    mapping(uint256 => Listing) public listings;\n    \n    constructor(address initialOwner) \n        ERC721(\"TravelMint NFT\", \"TRAVEL\") \n        Ownable(initialOwner)\n    {\n        _nextTokenId = 1;\n    }\n    \n    /**\n     * @dev Mint a new Travel NFT with USDC payment\n     * @param to Address to mint the NFT to\n     * @param location Location string (city name or coordinates)\n     * @param latitude GPS latitude as string\n     * @param longitude GPS longitude as string  \n     * @param category Photo category\n     * @param tokenURI IPFS hash or metadata URI\n     */\n    function mintTravelNFT(\n        address to,\n        string memory location,\n        string memory latitude,\n        string memory longitude,\n        string memory category,\n        string memory tokenURI\n    ) public nonReentrant returns (uint256) {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(bytes(location).length > 0, \"Location cannot be empty\");\n        require(bytes(tokenURI).length > 0, \"Token URI cannot be empty\");\n        \n        // Transfer USDC from sender to contract owner\n        bool success = USDC.transferFrom(msg.sender, owner(), MINT_PRICE);\n        require(success, \"USDC transfer failed\");\n        \n        uint256 tokenId = _nextTokenId++;\n        \n        // Mint NFT\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n        \n        // Store travel metadata\n        travelMetadata[tokenId] = TravelMetadata({\n            location: location,\n            latitude: latitude, \n            longitude: longitude,\n            category: category,\n            mintTimestamp: block.timestamp,\n            originalMinter: msg.sender\n        });\n        \n        emit TravelNFTMinted(to, tokenId, location);\n        \n        return tokenId;\n    }\n    \n    /**\n     * @dev Batch mint multiple NFTs (gas efficient)\n     */\n    function batchMintTravelNFT(\n        address[] memory recipients,\n        string[] memory locations,\n        string[] memory latitudes,\n        string[] memory longitudes,\n        string[] memory categories,\n        string[] memory tokenURIs\n    ) external nonReentrant returns (uint256[] memory) {\n        require(recipients.length == locations.length, \"Arrays length mismatch\");\n        require(recipients.length == latitudes.length, \"Arrays length mismatch\");\n        require(recipients.length == longitudes.length, \"Arrays length mismatch\");\n        require(recipients.length == categories.length, \"Arrays length mismatch\");\n        require(recipients.length == tokenURIs.length, \"Arrays length mismatch\");\n        \n        uint256[] memory tokenIds = new uint256[](recipients.length);\n        uint256 totalCost = MINT_PRICE * recipients.length;\n        \n        // Transfer total USDC amount\n        bool success = USDC.transferFrom(msg.sender, owner(), totalCost);\n        require(success, \"USDC transfer failed\");\n        \n        for (uint256 i = 0; i < recipients.length; i++) {\n            uint256 tokenId = _nextTokenId++;\n            \n            _safeMint(recipients[i], tokenId);\n            _setTokenURI(tokenId, tokenURIs[i]);\n            \n            travelMetadata[tokenId] = TravelMetadata({\n                location: locations[i],\n                latitude: latitudes[i],\n                longitude: longitudes[i], \n                category: categories[i],\n                mintTimestamp: block.timestamp,\n                originalMinter: msg.sender\n            });\n            \n            tokenIds[i] = tokenId;\n            emit TravelNFTMinted(recipients[i], tokenId, locations[i]);\n        }\n        \n        return tokenIds;\n    }\n    \n    /**\n     * @dev Get travel metadata for a token\n     */\n    function getTravelMetadata(uint256 tokenId) external view returns (TravelMetadata memory) {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        return travelMetadata[tokenId];\n    }\n    \n    /**\n     * @dev Get next token ID\n     */\n    function getNextTokenId() external view returns (uint256) {\n        return _nextTokenId;\n    }\n    \n    /**\n     * @dev List NFT for sale - SECURITY FIX: Only owner can list with stored price\n     * @param tokenId The NFT token ID to list\n     * @param price The price in USDC (with 6 decimals)\n     */\n    function listNFT(uint256 tokenId, uint256 price) external {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        require(ownerOf(tokenId) == msg.sender, \"Only NFT owner can list\");\n        require(price > 0, \"Price must be greater than 0\");\n        \n        listings[tokenId] = Listing({\n            seller: msg.sender,\n            price: price,\n            active: true\n        });\n        \n        emit NFTListed(tokenId, msg.sender, price);\n    }\n    \n    /**\n     * @dev Cancel NFT listing - Only seller can cancel\n     * @param tokenId The NFT token ID to unlist\n     */\n    function cancelListing(uint256 tokenId) external {\n        Listing storage listing = listings[tokenId];\n        require(listing.active, \"NFT is not listed\");\n        require(listing.seller == msg.sender, \"Only seller can cancel listing\");\n        \n        listing.active = false;\n        emit NFTUnlisted(tokenId, msg.sender);\n    }\n    \n    /**\n     * @dev Update NFT price - Only seller can update\n     * @param tokenId The NFT token ID to update price for\n     * @param newPrice The new price in USDC (with 6 decimals)\n     */\n    function updatePrice(uint256 tokenId, uint256 newPrice) external {\n        Listing storage listing = listings[tokenId];\n        require(listing.active, \"NFT is not listed\");\n        require(listing.seller == msg.sender, \"Only seller can update price\");\n        require(newPrice > 0, \"Price must be greater than 0\");\n        \n        uint256 oldPrice = listing.price;\n        listing.price = newPrice;\n        \n        emit PriceUpdated(tokenId, msg.sender, oldPrice, newPrice);\n    }\n    \n    /**\n     * @dev Purchase NFT with USDC - SECURITY FIX: Uses stored price and requires active listing\n     * @param tokenId The NFT token ID to purchase\n     */\n    function purchaseNFT(uint256 tokenId) external nonReentrant {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        \n        // ðŸ”’ SECURITY FIX: Check listing exists and is active\n        Listing storage listing = listings[tokenId];\n        require(listing.active, \"NFT is not listed for sale\");\n        \n        address seller = ownerOf(tokenId);\n        require(seller == listing.seller, \"Listing seller mismatch\");\n        require(seller != msg.sender, \"Cannot buy your own NFT\");\n        \n        // ðŸ”’ SECURITY FIX: Use stored price, not buyer-provided price\n        uint256 price = listing.price;\n        require(price > 0, \"Invalid listing price\");\n        \n        // Calculate commission split\n        uint256 platformFee = (price * PLATFORM_FEE_PERCENT) / 100;\n        uint256 sellerAmount = price - platformFee;\n        \n        // Transfer USDC from buyer to seller (95%)\n        bool sellerSuccess = USDC.transferFrom(msg.sender, seller, sellerAmount);\n        require(sellerSuccess, \"USDC transfer to seller failed\");\n        \n        // Transfer platform commission (5%)\n        bool platformSuccess = USDC.transferFrom(msg.sender, PLATFORM_WALLET, platformFee);\n        require(platformSuccess, \"USDC transfer to platform failed\");\n        \n        // Transfer NFT from seller to buyer\n        _transfer(seller, msg.sender, tokenId);\n        \n        // ðŸ”’ SECURITY FIX: Clear listing after successful purchase\n        listing.active = false;\n        \n        emit NFTPurchased(tokenId, msg.sender, seller, price, platformFee);\n    }\n\n    /**\n     * @dev Emergency withdraw function for owner\n     */\n    function withdrawUSDC() external onlyOwner {\n        uint256 balance = USDC.balanceOf(address(this));\n        require(balance > 0, \"No USDC to withdraw\");\n        \n        bool success = USDC.transfer(owner(), balance);\n        require(success, \"USDC withdrawal failed\");\n    }\n    \n    /**\n     * @dev Update mint price (only owner)\n     */\n    function updateMintPrice(uint256 newPrice) external onlyOwner {\n        // Note: This would require a storage variable for mint price\n        // For now, mint price is constant at 1 USDC\n        revert(\"Mint price is fixed at 1 USDC\");\n    }\n\n    /**\n     * @dev Claim Base network reward - simple on-chain transaction for quest\n     */\n    function claimBaseReward() external payable {\n        // Minimal transaction fee required (0.0001 ETH)\n        require(msg.value >= 0.0001 ether, \"Minimum fee required: 0.0001 ETH\");\n        \n        // Emit event for quest tracking\n        emit BaseRewardClaimed(msg.sender, msg.value, block.timestamp);\n    }\n    \n    // New event for Base reward claims\n    event BaseRewardClaimed(address indexed user, uint256 amount, uint256 timestamp);\n\n    // Required overrides\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ]
      }
    }
  }
}